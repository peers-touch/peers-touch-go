# Protocol Buffer Guidelines for Peers Touch Projects

## Overview

This document provides detailed guidelines for using the `peers-touch-proto` repository as the central hub for all protocol buffer definitions across Peers Touch projects.

## Why Centralized Proto Definitions?

1. **Consistency**: Ensures consistent data structures across all projects
2. **Single Source of Truth**: Prevents duplicate or conflicting definitions
3. **Versioning**: Simplifies tracking changes to data models
4. **Reusability**: Promotes reuse of common data structures
5. **Compatibility**: Ensures backward compatibility between services

## Mandatory Rules

### 1. Define First, Implement Later

All data models used for cross-project communication MUST be defined in the `peers-touch-proto` repository before implementation begins. This includes:

- API request/response structures
- Event payloads
- Shared data models
- Service definitions

### 2. No Auto-Generation

Protocol buffers should NOT be automatically generated by individual projects. All proto files must be manually created and reviewed.

### 3. No Duplicate Definitions

Never create duplicate proto definitions in individual projects. Always import the generated code from this repository.

## Naming Conventions

### File Names

- Use snake_case for file names: `feature_name.proto`
- Group related messages in a single file
- Name files after the primary feature they support

### Package Names

```protobuf
package peers_touch.v1.feature_name;
```

### Go Package Option

```protobuf
option go_package = "github.com/dirty-bro-tech/peers-touch-proto/v1/feature_name";
```

### Message Names

- Use PascalCase for message names: `UserProfile`
- Be descriptive and specific
- Avoid generic names like "Data" or "Info"

### Field Names

- Use snake_case for field names: `first_name`
- Be descriptive but concise
- Use consistent naming across related messages

## Best Practices

### Message Design

1. **Single Responsibility**: Each message should represent a single concept
2. **Reusability**: Design messages to be reusable across different contexts
3. **Extensibility**: Plan for future extensions by using reserved fields
4. **Validation**: Document validation requirements in comments

### Field Numbers

1. **Reserve Important Fields**: Use lower numbers (1-15) for frequently used fields
2. **Reserve Removed Fields**: Always reserve field numbers that are removed
3. **Documentation**: Document the purpose of each field

### Versioning

1. **Directory Structure**: Use versioned directories (`v1/`, `v2/`, etc.)
2. **Backward Compatibility**: Maintain backward compatibility within a version
3. **Breaking Changes**: Create a new version for breaking changes

## Example Workflow

### Correct Workflow

1. Identify need for a new data model for cross-project communication
2. Define the proto file in `peers-touch-proto/v1/`
3. Run `./generate.sh` to generate code for all targets
4. Import the generated code in your projects
5. Implement your feature using the generated code

### Incorrect Workflow (Do Not Do This)

1. ❌ Start implementing a feature in your project
2. ❌ Create local data models for cross-project communication
3. ❌ Try to retrofit these models into proto files later

## Example Proto File

```protobuf
syntax = "proto3";

package peers_touch.v1.user;

option go_package = "github.com/dirty-bro-tech/peers-touch-proto/v1/user";

// UserProfile represents a user's profile information
message UserProfile {
  string user_id = 1;  // Unique identifier for the user
  string username = 2;  // Display name
  string avatar_url = 3;  // URL to user's avatar image
  
  // Status information
  enum Status {
    UNKNOWN = 0;
    ONLINE = 1;
    AWAY = 2;
    OFFLINE = 3;
  }
  Status status = 4;
  
  // Reserved for future use
  reserved 5 to 10;
}

// UserService provides operations for managing user profiles
service UserService {
  // GetUserProfile retrieves a user's profile by ID
  rpc GetUserProfile(GetUserProfileRequest) returns (GetUserProfileResponse);
  
  // UpdateUserProfile updates a user's profile information
  rpc UpdateUserProfile(UpdateUserProfileRequest) returns (UpdateUserProfileResponse);
}

message GetUserProfileRequest {
  string user_id = 1;
}

message GetUserProfileResponse {
  UserProfile profile = 1;
}

message UpdateUserProfileRequest {
  UserProfile profile = 1;
}

message UpdateUserProfileResponse {
  UserProfile profile = 1;
}
```

## Enforcement

### Code Review Checklist

When reviewing code that involves cross-project communication, check:

- [ ] Are all data models defined in the `peers-touch-proto` repository?
- [ ] Is the code using the generated proto code rather than custom models?
- [ ] Are proto definitions following the naming conventions?
- [ ] Are proto definitions well-documented?

### CI/CD Integration

Consider implementing checks in your CI/CD pipeline:

1. Verify that no proto files exist outside the central repository
2. Ensure all projects are using the latest generated code
3. Run compatibility tests between services

## Troubleshooting

### Common Issues

1. **Generated Code Not Found**: Ensure you've run `./generate.sh` after defining your proto files
2. **Import Errors**: Check that your project's import paths match the generated code structure
3. **Version Mismatch**: Ensure all projects are using the same version of the proto definitions

## Conclusion

Following these guidelines ensures a consistent, maintainable approach to cross-project communication in the Peers Touch ecosystem. By centralizing proto definitions, we reduce duplication, improve consistency, and make it easier to evolve our data models over time.