# 模块开发标准操作程序 (SOP)

## 概述

本SOP定义了在Peers Touch桌面应用中开发新功能模块的标准流程和规范。遵循此SOP可确保代码质量、架构一致性和团队协作效率。

## 模块开发流程

### 阶段1：需求分析与设计

#### 1.1 功能需求确认
- [ ] 明确模块的核心功能
- [ ] 确定用户交互流程
- [ ] 定义MVP功能范围
- [ ] 识别依赖的外部服务

#### 1.2 技术方案设计
- [ ] 确定模块在架构中的位置
- [ ] 设计数据模型结构
- [ ] 规划API接口（如有）
- [ ] 评估性能和安全需求

#### 1.3 UI/UX设计确认
- [ ] 遵循LobeChat设计风格
- [ ] 确认三栏布局适配
- [ ] 设计交互动画效果
- [ ] 确认颜色主题适配

### 阶段2：目录结构创建

#### 2.1 标准目录结构
```
features/{module_name}/
├── {module_name}_module.dart          # 模块注册入口
├── {module_name}_binding.dart         # 依赖注入绑定
├── controller/                        # 控制器层
│   └── {module_name}_controller.dart  # 主控制器
├── view/                              # 视图层
│   ├── {module_name}_page.dart        # 主页面
│   └── components/                    # 组件目录
├── model/                            # 数据模型层
├── service/                          # 服务层
└── widgets/                         # 可复用组件
```

#### 2.2 文件命名规范
- 使用蛇形命名法（snake_case）
- 控制器文件：`{module_name}_controller.dart`
- 页面文件：`{module_name}_page.dart`
- 模型文件：`{model_name}.dart`

### 阶段3：模块注册实现

#### 3.1 模块注册文件
```dart
// features/{module_name}/{module_name}_module.dart
import 'package:flutter/material.dart';
import 'package:peers_touch_desktop/features/shell/manager/primary_menu_manager.dart';

class {ModuleName}Module {
  static void register() {
    PrimaryMenuManager.registerItem(PrimaryMenuItem(
      id: '{module_name}',
      label: '{模块显示名称}',
      icon: Icons.{图标名称},
      isHead: {true/false},          // true=头部区域，false=尾部区域
      order: {排序权重},              // 区域内的排序权重
      contentBuilder: (context) => {ModuleName}ContentPage(),
    ));
  }
}

class {ModuleName}ContentPage extends StatelessWidget {
  const {ModuleName}ContentPage({super.key});

  @override
  Widget build(BuildContext context) {
    return GetBuilder<{ModuleName}Controller>(
      init: {ModuleName}Controller(),
      builder: (controller) {
        return {ModuleName}Page(controller: controller);
      },
    );
  }
}
```

#### 3.2 依赖注入绑定
```dart
// features/{module_name}/{module_name}_binding.dart
import 'package:get/get.dart';
import '{module_name}_controller.dart';

class {ModuleName}Binding extends Bindings {
  @override
  void dependencies() {
    Get.lazyPut<{ModuleName}Controller>(() => {ModuleName}Controller());
  }
}
```

### 阶段4：核心功能实现

#### 4.1 控制器开发规范
```dart
// 必须继承GetxController
class {ModuleName}Controller extends GetxController {
  // 状态变量使用Rx包装
  final isLoading = false.obs;
  final dataList = <String>[].obs;
  
  // 业务逻辑方法
  Future<void> loadData() async {
    isLoading.value = true;
    try {
      // 业务逻辑
    } catch (e) {
      // 错误处理
    } finally {
      isLoading.value = false;
    }
  }
  
  @override
  void onInit() {
    super.onInit();
    // 初始化逻辑
  }
  
  @override
  void onClose() {
    // 清理逻辑
    super.onClose();
  }
}
```

#### 4.2 页面布局规范
```dart
// 必须遵循LobeChat三栏布局
class {ModuleName}Page extends StatelessWidget {
  final {ModuleName}Controller controller;
  
  const {ModuleName}Page({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        // 左侧导航栏 (280px固定宽度)
        Container(
          width: 280,
          decoration: const BoxDecoration(
            color: Color(0xFF252525),
            border: Border(right: BorderSide(color: Color(0xFF2D2D2D), width: 1)),
          ),
          child: // 左侧内容
        ),
        
        // 主内容区域
        Expanded(
          child: Container(
            color: const Color(0xFF1A1A1A),
            child: // 主内容
          ),
        ),
        
        // 右侧面板 (可选，320px固定宽度)
        Container(
          width: 320,
          decoration: const BoxDecoration(
            color: Color(0xFF252525),
            border: Border(left: BorderSide(color: Color(0xFF2D2D2D), width: 1)),
          ),
          child: // 右侧内容
        ),
      ],
    );
  }
}
```

### 阶段5：服务层实现

#### 5.1 服务接口设计
```dart
// 定义抽象接口
abstract class {ModuleName}Service {
  Future<ResultType> methodName(ParameterType param);
}

// 具体实现
class {ModuleName}ServiceImpl implements {ModuleName}Service {
  @override
  Future<ResultType> methodName(ParameterType param) async {
    // 具体实现
  }
}
```

#### 5.2 网络请求规范
- 使用项目现有的ApiClient
- 统一错误处理机制
- 支持重试逻辑

### 阶段6：测试与验证

#### 6.1 单元测试
```dart
// test/features/{module_name}/{module_name}_controller_test.dart
void main() {
  group('{ModuleName}Controller Tests', () {
    late {ModuleName}Controller controller;
    
    setUp(() {
      controller = {ModuleName}Controller();
    });
    
    test('Initial state is correct', () {
      expect(controller.isLoading.value, false);
    });
  });
}
```

#### 6.2 集成测试
- 验证模块注册是否正确
- 测试页面导航流程
- 验证依赖注入工作正常

### 阶段7：文档与部署

#### 7.1 代码文档
- 为所有公共方法添加文档注释
- 更新README文件
- 添加使用示例

#### 7.2 部署检查清单
- [ ] 模块正确注册到PrimaryMenuManager
- [ ] 依赖注入绑定正常工作
- [ ] 页面布局符合LobeChat规范
- [ ] 所有功能测试通过
- [ ] 代码符合项目lint规则

## 最佳实践

### 代码质量
- 遵循Dart语言最佳实践
- 使用强类型和空安全
- 保持函数单一职责
- 编写可测试的代码

### 性能优化
- 使用懒加载减少初始内存占用
- 实现列表项状态保持
- 优化图片和资源加载
- 避免不必要的重绘

### 可维护性
- 使用有意义的变量名
- 保持一致的代码风格
- 及时重构重复代码
- 添加适当的日志记录

## 常见问题与解决方案

### Q: 如何处理模块间的依赖？
A: 通过依赖注入容器管理，避免直接实例化。使用Get.find<T>()获取服务。

### Q: 模块需要访问全局状态怎么办？
A: 通过GetX的全局状态管理，或使用项目现有的全局服务。

### Q: 如何确保UI一致性？
A: 严格遵循LobeChat设计规范，使用项目定义的颜色和尺寸常量。

### Q: 模块开发完成后如何集成？
A: 在AppInitializer中调用模块的register()方法，确保在应用启动时正确注册。

## 版本历史

- v1.0: 初始版本，基于现有项目规范制定
- v1.1: 增加详细实现示例和最佳实践

---

通过遵循此SOP，可以确保每个新模块都符合项目架构规范，提高代码质量和团队协作效率。