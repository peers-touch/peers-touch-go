# 存储层设计（纯净版：本地持久 + 多后端接口，业务解耦）

## 目标
- 客户端数据既要可靠存本地，又要按不同业务调用不同后端接口进行持久化或读取；同时与业务代码完全解耦。
- 所有“数据持久化/读取”统一经过存储层（Storage），业务不直接触碰 HTTP；存储层内部复用网络层的 HTTP 客户端。
- 以资源为中心（resource-centric），不依赖业务模型类型；资源路由与策略来自配置或约定，运行时可替换。

## 非目标
- 不在存储层定义任何业务模型类型（如 User/Message）；这些只存在于上层 Repository。
- 不在存储层硬编码任何业务接口路径；优先约定与配置，必要时可插件式覆盖。

## 分层架构
- 上层：UI/业务逻辑
- Repository：负责模型序列化/反序列化，仅与 Storage 交互
- StorageService：统一文档与集合操作（create/read/update/delete/query/batch）
- LocalStore：本地结构化存储（DB/KV/Blob）
- RemoteStore：HTTP 驱动（标准 REST），按资源路由调用不同后端接口
- PolicyEngine：资源策略（本地/云端/安全/空间/同步）
- Sync（可选）：Outbox/Inbox + Coordinator，实现 offline-first

## 资源与策略（纯配置，脱离业务）
- 资源标识：`resourceCode`（如 `chat.message`、`cfg.provider`），仅是字符串，不绑定模型类型。
- 路由约定：默认 `endpoint = '/touch/{resourceCode}'` 或 `'/v1/touch/{resourceCode}'`。
- 路由覆盖（可选）：通过配置 `storage_routes.json` 将 `resourceCode -> endpoint` 映射；无需解析器类，直接读配置即可（更纯净）。
- 策略配置：`storage_policies.json` 为每个 `resourceCode` 定义：
  - local：`persistent(true/false)`, `db('drift|isar|hive')`, `table`, `indexes`, `retentionDays`, `quotaMB`, `encrypted(true/false)`
  - remote：`methodSet(['GET','POST','PATCH','DELETE'])`, `version('/v1')`, `conflict('lww|merge|manual')`, `idempotencyKey(field)`
  - security：`privacyLevel('pii|secret|telemetry')`, `encryptionKeyRef('system|app')`, `masking`
  - sync：`mode('offline_first|online_first|none')`, `checkpoint(field)`, `retry(backoff)`

## 核心接口（Dart，与业务解耦）
```dart
typedef Document = Map<String, dynamic>;

class QueryOptions { final Map<String,dynamic>? filters; final int? page; final int? size; const QueryOptions({this.filters,this.page,this.size}); }
class Page<T> { final List<T> items; final int page; final int size; final int total; const Page(this.items,this.page,this.size,this.total); }

// 资源路由与策略来源：纯配置
abstract class RouteProvider { String endpointOf(String resourceCode); }
class JsonRouteProvider implements RouteProvider {
  final Map<String,String> map; JsonRouteProvider(this.map);
  @override String endpointOf(String code) => map[code] ?? '/touch/$code';
}

abstract class StorageDriver {
  Future<Document> create(String resourceCode, Document doc);
  Future<Document> readOne(String resourceCode, String id);
  Future<Page<Document>> readMany(String resourceCode, QueryOptions q);
  Future<Document> update(String resourceCode, String id, Document patch, {String? ifMatch});
  Future<void> delete(String resourceCode, String id);
}

class HttpStorageDriver implements StorageDriver {
  final Dio dio; final String baseUrl; final RouteProvider routes; final String basePrefix; // e.g. '/v1'
  HttpStorageDriver(this.dio, this.baseUrl, this.routes, {this.basePrefix = ''});
  String _ep(String code) { final ep = routes.endpointOf(code); return '$baseUrl${basePrefix}$ep'; }
  @override Future<Document> create(String code, Document doc) async { final r = await dio.post(_ep(code), data: doc); return r.data as Document; }
  @override Future<Document> readOne(String code, String id) async { final r = await dio.get('${_ep(code)}/$id'); return r.data as Document; }
  @override Future<Page<Document>> readMany(String code, QueryOptions q) async {
    final r = await dio.get(_ep(code), queryParameters: {...?q.filters,'page':q.page,'size':q.size});
    final d = r.data as Map<String,dynamic>; return Page<Document>(List<Map<String,dynamic>>.from(d['items']), d['page'], d['size'], d['total']);
  }
  @override Future<Document> update(String code, String id, Document patch, {String? ifMatch}) async {
    final r = await dio.patch('${_ep(code)}/$id', data: patch, options: Options(headers: ifMatch!=null?{'If-Match':ifMatch}:null)); return r.data as Document;
  }
  @override Future<void> delete(String code, String id) async { await dio.delete('${_ep(code)}/$id'); }
}

class StorageService {
  final StorageDriver remote; // 仅云端；本地通过 LocalStore 独立管理
  StorageService(this.remote);
  Future<Document> create(String resourceCode, Document doc) => remote.create(resourceCode, doc);
  Future<Document> readOne(String resourceCode, String id) => remote.readOne(resourceCode, id);
  Future<Page<Document>> readMany(String resourceCode, QueryOptions q) => remote.readMany(resourceCode, q);
  Future<Document> update(String resourceCode, String id, Document patch, {String? ifMatch}) => remote.update(resourceCode, id, patch, ifMatch: ifMatch);
  Future<void> delete(String resourceCode, String id) => remote.delete(resourceCode, id);
}
```

## 本地存储（与业务解耦）
- 建议选型：Drift（结构化查询）或 Isar（高性能），小体量用 Hive/KV。
- 统一接口：`LocalStore.put(resourceCode, key, doc)`、`LocalStore.get(resourceCode, key)`、`LocalStore.query(resourceCode, Query)`。
- 表名与索引：从 `storage_policies.json` 读取，不在代码硬编码。
- 加密：按策略对指定 `resourceCode` 的字段/整行加密（AES-GCM），密钥来自系统安全存储。

## 同步（可选，离线优先）
- Outbox：所有云写操作先写到本地出站表，带幂等键；后台可靠投递；成功后更新本地行状态。
- Inbox：按 `resourceCode` 维护 checkpoint 增量拉取；合入本地并发出订阅事件。
- Coordinator：统一调度重试、限流、冲突（LWW/字段合并/人工介入）。

## 安全与空间
- 传输：TLS + 认证拦截器；可选证书钉扎。
- 本地：敏感资源加密、密钥分域与轮换；删除即擦除（密钥销毁或安全删除）。
- 空间：每资源配额与保留期；热温冷分层（近期热数据、老数据仅元信息）；附件单独 Blob 存储并去重（哈希）。

## 与 network/settings 集成
- `backend_url`：从设置读取并注入 `HttpStorageDriver`；`Dio` 复用 network 的鉴权/重试/日志。
- 路由：优先按约定拼接；如提供 `storage_routes.json` 则覆盖对应资源路径。

## 业务层的使用（保持解耦）
- Repository 仅处理模型 <-> Document 的转换；调用时传 `resourceCode`，不关心 endpoint。
```dart
class ChatRepository {
  final StorageService storage; ChatRepository(this.storage);
  Future<Message> send(Message m) async {
    final doc = await storage.create('chat.message', m.toJson());
    return Message.fromJson(doc);
  }
  Stream<List<Message>> watchLocalConversation(String convoId) { /* 通过 LocalStore 订阅本地 */ }
}

class ProviderConfigRepository {
  final StorageService storage; ProviderConfigRepository(this.storage);
  Future<ProviderConfig> load() async {
    final page = await storage.readMany('cfg.provider', const QueryOptions(page:1,size:1));
    return ProviderConfig.fromJson(page.items.first);
  }
}
```

## 初始化示例（纯约定 + 配置）
```dart
final Dio dio = Get.find<Dio>();
final String baseUrl = Get.find<SettingManager>().getValue('backend_url');
final routes = JsonRouteProvider({ // 可为空：为空则走约定 '/touch/{code}'
  'chat.message': '/touch/messages',
  'cfg.provider': '/touch/provider-config',
});
final storage = StorageService(HttpStorageDriver(dio, baseUrl, routes, basePrefix: '/v1'));
// 业务层：只用 resourceCode，不依赖接口路径
```

## 选择与取舍
- 约定优先：更简单稳定；跨业务仍解耦。
- 配置覆盖：满足多接口/迁移/租户差异，无需在代码内写路由逻辑。
- 无模型类型映射：不以类型获取表名或路径，从根源避免耦合。

## 小结
- 本方案通过“resourceCode + 约定路由 + 可选配置覆盖”的方式，做到本地与云端统一、不同业务接口可按资源分流，且与业务彻底解耦。
- 需要我进一步在 `desktop/lib/core/storage/` 创建最小骨架（RouteProvider/HttpStorageDriver/StorageService/LocalStore 接口）并给出两个 Repository 示例吗？