# 全局UI架构骨架（LobeChat 风格）

> 聚焦 “三栏骨架的精确尺寸约束、区域划分、交互联动逻辑”，基于 LobeChat 的设计理念，仅定义 UI 的 “纯结构规则”，不涉及具体视觉样式。

## 核心定位

基于 LobeChat 的桌面端**四级导航结构**设计，本阶段仅定义 UI 的 "纯骨架结构"—— 精确量化四级导航的尺寸、区域划分、层级递进关系，不涉及骨架内的具体内容（如颜色、图标、文字等），仅聚焦 "容器本身的规则"。

**LobeChat 真实布局精髓**：四级导航层级递进，从左到右依次为：一级菜单栏 → 二级导航栏 → 主内容区 → 辅助面板。“容器本身的规则”。

## 设计参考基准

**LobeChat 四级导航结构精髓**：
- **一级菜单栏**：固定宽度 64px，垂直排列核心功能入口图标
- **二级导航栏**：固定宽度 280px，承载一级菜单对应的具体导航内容
- **主内容区**：自适应宽度，最大宽度限制 1200px（保证最佳阅读体验）
- **辅助面板**：采用 overlay 浮动覆盖模式，不挤压主内容区
- **层级递进关系**：一级菜单 → 二级导航 → 主内容 → 辅助信息
- 各区域高度精确划分，支持独立滚动
- 超宽屏幕内容区居中，两侧留空背景色

### LobeChat布局核心特征

#### 右侧面板overlay模式

- **浮动覆盖设计**：右侧面板展开时浮动覆盖在内容区右侧
- **背景遮罩**：展开时显示半透明遮罩层（透明度 0.3，颜色 #1A1A1A）
- **遮罩交互**：点击遮罩层自动关闭右侧面板，提供视觉反馈（透明度变化 0.3 → 0.5）
- **不挤压内容**：面板展开/折叠不影响中间内容区的宽度
- **折叠状态**：收缩为 48px 宽边缘图标栏，垂直排列常用功能
- **层级管理**：遮罩层 z-index: 100，右侧面板 z-index: 200，确保正确覆盖关系

#### 内容区宽度约束
- **最小宽度**：720px（确保基本可用性）
- **最佳宽度**：800-1000px（LobeChat阅读舒适区）
- **最大宽度**：1200px（防止过宽影响阅读体验）
- **超宽处理**：>1400px时内容区居中，两侧留空 #1E1E1E 背景

#### 折叠动画细节
- **展开动画**：300ms缩放 + 淡入淡出，缓动曲线 ease-out
- **折叠动画**：300ms缩放 + 淡出，缓动曲线 ease-in
- **过渡状态**：面板缩放中心为左侧边缘，确保自然流畅
- **交互反馈**：hover时图标有轻微放大效果（scale 1.05），过渡时长 150ms
- **焦点管理**：面板展开时自动聚焦到第一个可交互元素
- **键盘导航**：支持 ESC 键关闭面板，Tab 键在面板内循环导航

#### 响应式断点处理
- **< 1000px**：隐藏右侧面板，在左侧栏提供替代入口（图标 + 文字提示）
- **1000-1400px**：标准三栏布局，右侧面板正常显示
- **> 1400px**：内容区居中显示，最大化阅读体验，两侧留空背景色 #1A1A1A
- **临界处理**：断点切换时有300ms淡入淡出过渡，避免布局跳跃
- **断点回退**：窗口缩放时保持当前布局状态，直到跨越断点阈值

#### 边缘情况处理
- **面板内容过长**：支持内部垂直滚动，滚动条样式统一为细条型
- **多面板冲突**：同一时间只允许一个右侧面板展开，其他自动关闭
- **性能优化**：面板内容使用懒加载，首次展开时加载必要内容
- **错误状态**：面板加载失败时显示错误占位，提供重试按钮
- **内存管理**：面板关闭时自动释放大内存资源，保持应用轻量

## 整体骨架结构（唯一核心：四级导航层级）

* **布局类型**：一级菜单栏 + 二级导航栏 + 主内容区 + 辅助面板，四级横向排列，全屏占比（100% 宽 ×100% 高）。
* **适配宽度范围**：800px ~ 2560px（**最小适配宽度 800px**，低于此宽度强制显示水平滚动条，禁止继续缩放；高于 2560px 时内容区居中，两侧留空 #1A1A1A 背景）。
* **系统最小宽度限制**：
    - **macOS**：最小窗口宽度 800px（系统级限制）
    - **Windows**：最小窗口宽度 800px（考虑任务栏和系统UI）
    - **Linux**：最小窗口宽度 800px（兼容不同桌面环境）
* **四级导航尺寸约束**：
    * **一级菜单栏**：固定宽度 64px，不随屏幕缩放（垂直排列核心功能入口）
    * **二级导航栏**：固定宽度 280px，不随屏幕缩放（承载一级菜单对应的具体导航）
    * **主内容区**：自适应宽度，**最小宽度 480px**、最大宽度无限制（视觉核心区，确保内容不溢出）
    * **辅助面板**：固定宽度 320px，支持折叠（折叠后宽度收缩至 48px，仅保留展开按钮）

* **高度约束**：四级导航均为 100% 全屏高度（从屏幕顶部到底部），各区域内部独立滚动（全局无整体滚动，仅单区域内部滚动）。
* 系统边框：暂时使用系统边框

## 四级导航核心定位与基础结构（仅定义 "容器规则"）

### 一级菜单栏：用户身份 + 功能入口

* **核心定位**：用户身份展示 + 全局功能入口容器，垂直排列用户信息和功能图标。
* **基础结构**（从上到下，仅定义区域划分，不定义内容）：
    * **头像块区域**：固定高度（80-100px），最顶部固定位置，用于用户头像、身份信息展示
    * **头部区域**：自适应高度，用于业务功能菜单（如 AI 对话、私密圈、公开动态等）
    * **尾部区域**：固定高度（80-100px），最底部固定位置，用于重要入口（如设置等）
* **基础交互规则**：
    * 头像块区域：点击可展开用户信息面板或相关操作
    * 头部区域：点击业务功能图标，切换对应的模块内容页面
    * 尾部区域：点击重要入口图标，切换对应的系统功能页面
    * 一级菜单栏整体不滚动，各区域高度固定

### 中间栏：主内容展示栏

* 核心定位：视觉焦点容器，承载当前选中功能的核心内容（是用户主要操作与浏览区域）。
* 基础结构（从上到下，仅定义区域划分，不定义内容）：
* 顶部栏：固定高度（56-64px），用于当前内容的 “标题展示”+“核心操作按钮”（如新建、刷新等）。
* 内容区：自适应高度（占中间栏 75%-85%），用于承载核心内容（仅定义为 “可滚动的内容容器”）。
* 底部栏：固定高度（48-64px），用于当前内容的 “快捷操作容器”（如输入框、发布按钮等）。
* 基础交互规则：
    * 内容区支持垂直滚动（滚动条样式统一为 “细条型”，不悬浮时隐藏，hover 时显示）。
    * 切换功能入口时，内容区仅 “容器刷新”（保留滚动容器的结构，不改变栏高、栏宽）。

### 右侧栏：辅助信息栏

* 核心定位：辅助容器，承载与中间栏当前内容相关的辅助信息（非核心操作区，可折叠）。
* 基础结构（从上到下，仅定义区域划分，不定义内容）：
* 顶部控制区：固定高度（56-64px），仅包含 “折叠 / 展开” 按钮（居右）。
* 辅助内容区：自适应高度（占右侧栏 85%-90%），用于承载辅助信息（仅定义为 “可滚动的内容容器”）。
* 基础结构（从上到下，仅定义区域划分，不定义内容）：
    * 顶部控制区：固定高度（56-64px），仅包含 “折叠 / 展开” 按钮（居右）。
    * 辅助内容区：自适应高度（占右侧栏 85%-90%），用于承载辅助信息（仅定义为 “可滚动的内容容器”）。
* 基础交互规则：
    * 折叠 / 展开：点击顶部按钮，右侧栏从 “20% 宽” 收缩至 “48px 宽”（仅保留展开按钮），再点击恢复；收缩时不影响左 / 中栏尺寸。
    * 辅助内容区支持独立垂直滚动（与中间栏滚动互不干扰）。

## 骨架级特殊状态处理（仅定义 “容器级表现”，不涉及内容）

* 加载状态：中间栏 / 右侧栏的 “内容容器” 内，显示与容器尺寸一致的 “灰色占位骨架”（无动画、无文字，仅保留容器轮廓）。
* 空状态：中间栏 / 右侧栏的 “内容容器” 无数据时，显示 “居中占位区”（仅保留容器轮廓，无插图 / 文字）。
* 错误状态：系统异常时，中间栏顶部显示 “通栏占位区”（用于承载错误提示，不改变三栏结构）。

## 四级导航注册机制规范（模块自主注册 + 区域位置管理）

### 一级菜单注册原则
* **模块自主注册**：features目录下的各个功能模块自主注册一级菜单项
* **区域位置管理**：一级菜单明确分为头部区域（业务功能）和尾部区域（重要入口）
* **菜单项定义**：每个一级菜单项包含唯一标识、显示标签、图标、区域位置、区域内排序
* **内容封装**：一级菜单项关联完整的模块内容页面（二级导航+主内容）

### 一级菜单管理器设计
* **区域分离存储**：头像块区域、头部区域菜单、尾部区域菜单分开存储管理
* **头像块特殊性**：头像块为固定内容，不参与模块注册，由系统统一管理
* **简化接口**：仅提供注册函数、获取头部列表函数、获取尾部列表函数
* **自动排序**：注册时自动按区域内排序权重排序

### 模块内容页面规范
* **完整封装**：每个功能模块负责自己的完整界面（二级导航 + 主内容）
* **点击即显示**：点击一级菜单项直接显示对应的模块内容页面
* **扩展面板管理**：扩展面板作为主内容块的延伸，由各个模块自行管理

### 区域位置定义
* **头部区域**：业务功能菜单（如AI对话、私密圈、公开动态），排在上面区域，使用频率高
* **尾部区域**：重要入口菜单（如设置、用户信息），沉在下面区域，使用频率低但重要

### 模块注册示例规范
* **业务模块**：注册到头部区域，order值控制业务功能间的显示顺序
* **系统模块**：注册到尾部区域，order值控制系统功能间的显示顺序
* **内容构建**：每个模块提供完整的内容页面构建器

### 全局快捷键注册器设计（仅设计，后续落地）

为避免快捷键冲突并提升跨模块复用性，定义统一的快捷键注册与路由机制：

- 核心组件：`GlobalShortcutRegistry`（单例）
  - 功能：注册/注销快捷键、冲突检测、作用域路由、启用/禁用管理。
  - 注册入口：与一级菜单注册同一生命周期，在模块 `register()` 中声明其可用快捷键。
- 描述结构：`ShortcutDescriptor`
  - `id`：唯一标识（建议 `feature.action` 形式，如 `ai_chat.toggle_topic_panel`）
  - `keys`：组合键描述（如 `Ctrl+Enter`，支持 `Ctrl|Cmd` 语义）
  - `scope`：`global | page | component`（全局/页面/组件级）
  - `priority`：冲突时优先级（数值越大越优先；系统保留最高）
  - `when`：上下文条件（如 `isStreaming == false && focus == input`）
  - `featureId`：所属模块（如 `ai_chat`），用于批量启停
- 冲突策略：
  - 同一 `keys` 在同一 `scope` 冲突时，按 `priority` 处理；若相同，则按 `when` 细化匹配，不满足条件的回落到下一候选。
  - 预留保留键位：`Ctrl+K`（全局搜索）、`Ctrl+Enter`（发送/确认）、`Ctrl+Shift+T`（右侧面板显隐）。业务模块应复用这些键位以提升一致性。
- 作用域路由：
  - `global`：无视页面，始终可触发（如系统搜索）。
  - `page`：仅当对应页面处于活动状态时生效（如 AI Chat 的发送）。
  - `component`：仅当组件获得焦点时生效（如输入框内的快捷操作）。
- 示例（伪代码，仅文档设计）：
```dart
class ShortcutDescriptor {
  final String id;
  final String keys;        // e.g. 'Ctrl+Enter' | 'Cmd+Enter'
  final String scope;       // 'global' | 'page' | 'component'
  final int priority;       // higher wins
  final bool Function(Map<String, dynamic> ctx) when; // context predicate
  final String featureId;
  const ShortcutDescriptor({
    required this.id,
    required this.keys,
    required this.scope,
    required this.priority,
    required this.when,
    required this.featureId,
  });
}

class GlobalShortcutRegistry {
  static final i = GlobalShortcutRegistry._();
  GlobalShortcutRegistry._();
  final _map = <String, List<ShortcutDescriptor>>{}; // keys -> list
  void register(ShortcutDescriptor d) {
    _map.putIfAbsent(d.keys, () => []).add(d);
    _map[d.keys]!.sort((a,b)=> b.priority.compareTo(a.priority));
  }
  void unregisterFeature(String featureId) {
    for (final k in _map.keys) {
      _map[k]!.removeWhere((d) => d.featureId == featureId);
    }
  }
  bool handle(String keys, Map<String, dynamic> ctx) {
    final list = _map[keys];
    if (list == null) return false;
    for (final d in list) {
      if (d.when(ctx)) { /* route to feature action */ return true; }
    }
    return false;
  }
}

// 模块注册示例（与一级菜单注册同生命周期）
void registerAIChatShortcuts() {
  GlobalShortcutRegistry.i.register(ShortcutDescriptor(
    id: 'ai_chat.send',
    keys: 'Ctrl+Enter',
    scope: 'page',
    priority: 50,
    when: (ctx) => ctx['page'] == 'ai_chat' && ctx['focus'] == 'input' && ctx['isStreaming'] == false,
    featureId: 'ai_chat',
  ));
  GlobalShortcutRegistry.i.register(ShortcutDescriptor(
    id: 'ai_chat.toggle_topic_panel',
    keys: 'Ctrl+Shift+T',
    scope: 'page',
    priority: 40,
    when: (ctx) => ctx['page'] == 'ai_chat',
    featureId: 'ai_chat',
  ));
}
```

上述为“设计级”约定，本期不落地实现，待骨架与模块稳定后再统一引入。

## 设置页架构规范（统一设置管理 + 业务模块注入）

### 设置页核心定位
* **统一设置管理**：全局统一的设置页面，集中管理所有系统设置项
* **业务模块注入**：支持业务模块将自身设置项注入到全局设置页
* **分类管理**：设置项按功能分类，左侧导航+右侧内容布局

### 设置项类型规范
* **分区标题**：用于设置项分组显示
* **开关切换**：布尔值设置项，支持开关控件
* **下拉选择**：枚举值设置项，支持下拉选择
* **文本输入**：字符串设置项，支持文本输入框
* **按钮操作**：触发操作的设置项
* **分割线**：视觉分隔设置项

### 设置管理器架构
* **单例模式**：SettingManager采用单例模式，全局统一管理
* **设置注册器**：SettingRegistry接口定义设置项注册规范
* **分区管理**：设置项按分区组织，支持动态添加分区

### 业务模块设置注入流程
* **模块注册时注入**：业务模块在注册时自动注入设置项到全局设置页
* **统一托管**：所有业务模块设置项统一在设置页管理
* **设置项定义**：每个设置项包含唯一ID、标题、描述、类型、默认值等

### 设置页面UI规范
* **左侧导航**：240px固定宽度，显示设置分区列表
* **右侧内容**：自适应宽度，显示当前分区的设置项
* **分区切换**：点击左侧分区，右侧内容动态切换
* **设置项布局**：标题+描述+控件的垂直布局，支持多种交互控件

### 设置项持久化规范
* **本地存储**：设置项值持久化存储到本地
* **实时同步**：设置项修改实时生效并保存
* **默认值管理**：支持设置项默认值配置

### 业务模块设置注入示例
* **AI Provider设置**：AI服务提供商配置（API密钥、模型选择等）
* **聊天配置**：聊天相关的个性化设置
* **扩展面板配置**：右侧扩展板的业务状态配置

### 设置页与扩展面板联动
* **统一配置源**：设置页和扩展面板共享同一配置源
* **实时同步**：设置项修改实时反映到扩展面板
* **业务状态管理**：扩展面板支持业务状态的实时配置

## 应用初始化管理规范（统一初始化流程）

### 核心原则
* **单一职责**：main.dart仅负责应用启动，不包含具体初始化逻辑
* **统一管理**：所有初始化操作统一在`AppInitializer`中管理
* **模块化**：支持按需初始化，避免不必要的性能开销
* **错误处理**：提供完善的初始化错误处理和重试机制

### 初始化管理器设计
* **单例模式**：`AppInitializer`采用单例模式，全局统一管理
* **阶段化初始化**：将初始化分为核心阶段和可选阶段
* **依赖注入**：支持依赖注入，便于测试和模块替换

### 初始化阶段定义
* **核心阶段**（应用启动必须完成）：
  - Flutter引擎初始化
  - 本地存储初始化（GetStorage）
  - 窗口管理器初始化
  - 主题系统初始化
* **可选阶段**（可按需延迟初始化）：
  - 网络服务初始化
  - 数据库初始化
  - 第三方服务初始化
  - 业务模块初始化

### 初始化流程规范
* **同步初始化**：核心依赖必须同步完成
* **异步初始化**：非核心依赖可异步执行
* **进度反馈**：支持初始化进度回调
* **超时处理**：设置合理的初始化超时时间

### 错误处理机制
* **分级错误**：区分致命错误和非致命错误
* **优雅降级**：非致命错误不影响应用启动
* **重试机制**：支持初始化失败后的自动重试
* **用户提示**：向用户提供友好的初始化状态反馈

### 代码结构示例
```dart
// main.dart - 简化后的入口文件
void main() {
  AppInitializer.initializeAndRun();
}

// AppInitializer - 统一的初始化管理器
class AppInitializer {
  static Future<void> initializeAndRun() async {
    await _initializeCoreDependencies();
    await _initializeOptionalDependencies();
    runApp(const App());
  }
  
  static Future<void> _initializeCoreDependencies() async {
    WidgetsFlutterBinding.ensureInitialized();
    await GetStorage.init();
    await WindowOptionsManager.initializeWindowManager();
  }
  
  static Future<void> _initializeOptionalDependencies() async {
    // 按需初始化的非核心依赖
  }
}
```
* 错误状态：系统异常时，主内容区顶部显示 "通栏占位区"（用于承载错误提示，不改变四级导航结构）。

## 输出要求

* 四级导航骨架结构示意图（仅标注四级导航比例、宽度 / 高度约束、区域划分，无任何具体内容）。
* 尺寸规则表（含适配宽度范围、四级导航比例、各区域固定高度、折叠后尺寸）。
* 基础交互规则图（仅展示 "一级菜单点击→二级导航切换→主内容更新→扩展面板管理" 的逻辑）。
* 注册与注入机制流程图（展示组件注册、动态注入、状态管理的完整流程）。

## UI统一规范（边界组件）

为保证不同页面的“头部框/边界组件”（如二级导航顶部搜索、列表头工具栏等）视觉与交互一致，制定如下规范：

- 适用范围：位于页面或侧栏边界的输入/搜索框与其右侧操作按钮组合，以及对应的容器区块。
- 对齐与尺寸：
  - 外边距：水平方向统一使用 `UIKit.spaceMd(context)`；输入与按钮之间使用 `UIKit.spaceSm(context)`。
  - 高度：统一为 `menuBarWidth * menuItemBoxRatio`（若主题提供 WeChatTokens），否则回退为 `UIKit.controlHeightMd`。
  - 排列：输入框与右侧按钮在同一行，按钮为等高正方形。
- 边框与圆角：
  - 边框厚度：`UIKit.dividerThickness`（1px）。
  - 边框颜色：`UIKit.dividerColor(context)`；聚焦时使用 `UIKit.inputFocusedBorder(context)`。
  - 圆角：输入/搜索框使用 `UIKit.radiusSm(context)`；按钮使用 `UIKit.radiusMd(context)`。
- 背景与填充：
  - 容器背景：跟随所在侧栏或头部区背景，统一使用 `UIKit.assistantSidebarBg(context)`（或模块对应的 bgLevel2）。
  - 输入与搜索框内部填充色：统一使用 `UIKit.inputFillLight(context)`（较当前主题的浅色填充）。
- 颜色与图标：
  - 输入内容文字颜色使用 `UIKit.textPrimary(context)`，占位/前缀图标使用 `UIKit.textSecondary(context)`。
- 组件复用：
  - 强制使用通用组件 `FrameActionCombo` 实现“输入+按钮”的组合，避免在业务代码中散落样式实现。

以上规范为强约束：新增或调整页面的边界组件时必须遵循，并复用统一的 UIKit 与通用组件接口。